# 람다식
익명 함수를 생성하기 위한 식으로 객제 지향 언어보다는 함수 지향 언어에 가깝다.
객체 지향과는 거리가 있는 얘기지만 자바에 람다식을 수용하는 이유는
```aidl
1.자바 코드가 매우 간결해지며
2.컬렉션의 요소를 필터링하거나 매핑해서 원하는 결과를 쉽게 집계할 수 있다.
```

람다식의 형태는 매개 변수를 가진 코드 블록이지만 런타임 시 익명 구현 객체를 생성한다.
```aidl
Runnable runnable = new Runnable(){
    public void run(){...}
};
```
위의 익명 객체를 아래의 람다식으로 표현할 수 있다.
```aidl
Runnable runnable = () -> {...};
```
### 람다식 문법
() 안에 있는 매개 변수 이름은 자유롭게 할 수 있다. <br>
-> 기호는 매개 변수를 이용하여 중괄호{}를 실행한다는 뜻 <br>
```aidl
(int a) -> {System.out.println(a);}
```
람다식은 매개 변수 타입을 일반적으로 언급하지 않는다.
```aidl
(a) -> {System.out.println(a);}
```
[하나의 매개변수] 만 있다면 ()생략가능 <br>
[하나의 실행문] 만 있다면 중괄호 {} 생략가능
```aidl
a -> System.out.println(a)
```
매개변수가 없다면 빈 괄호() 를 반드시 사용해야 한다.
```aidl
() -> {실행문;...}
```
중괄호 {}를 실행하고 return 값이 있어야 한다면?
```aidl
(x,y) -> {return x+y; }
```
중괄호애 return 문만 있다면, 람다식은 return문을 사용하지 않는다
```aidl
(x,y) -> x+y
```

## 타겟 타입과 함수적 인터페이스
함다식은 하나의 메소드를 정의하기 때문에 2개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용하여 구현객체를 생성할 수 없다.
>이는 하나의 추상 메소드만 선언된 인터페이스만이 람다식의 타겟이 될수 있는 것이다.

>함수적 인터페이스를 이용할땐 @FunctionalInterface 어노테이션을 사용하여 메소드의 개수를 판별한다.
```aidl
@FunctionalInterface
public interface MyFunctionalInterface{
    public void method();
    public void otherMethod(); //컴파일 오류
}

어노테이션과 상관없이 하나의 추상 메소드만 있다면 모두 함수적 인터페이스이다.
```